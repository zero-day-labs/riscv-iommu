#   IO Access Arbitration Logic

    The IO Access Arbitration logic uses stream arbiters for AR and AW Channels. As requests are accepted, the ID of devices requesting write is stored in a FIFO to select the correct W channel, since write bursts are not identified by a WID signal.

    It is not necessary to store the ID of devices requesting to read, as incoming streams through R channel are identified by RID. The same occurs for the write response channel (B).

    Input channels (R, B) use stream demuxes to perform an AXI handshake (only VALID/READY signals) with the correct device. Remaining R and B input signals are directly connected for each device to the output master port.

    If two devices perform requests of different type (r/w) at the same time, these requests reach the output port independently, since involved channels are independent

    If two or more devices perform requests of the same type at the same time, the stream arbiter selects only one at a time. AXI requests naturally remain active until a handshake occurs (blocking). For AW requests, the AWID is saved in a FIFO to forward the write data through the corresponding W channel.

### Translation Requests

    The output of the IO Access Arbitration module is connected to the Translation Request IF of the IOMMU. Two translation requests may arrive at the same time if they are from different types (r/w). However, the IOMMU processes only one request at a time (priority is given to read requests).

    The AxVALID signal triggers the channel selection logic. When having a read request and a write request pending at the same time, the write request holds until the translation for the read request is completed and no other device has a read request pending. May need to alternate priorities.

    Another bit is set for the selected request, triggering the boundary check logic to guarantee that the transaction won't cross a 4kiB address boundary, which is prohibited by the AXI standard. This logic sets a unified allow_request bit if no address boundary violation is detected. Otherwise, a unified boundary_violation bit is set.

    The allow_request bit triggers the translation logic, which can successfully perform the address translation setting the trans_valid bit, or an error may occur and the trans_error bit is set.

    The trans_valid bit selects the AXI slave to which the bus is connected. When set, the AXI bus is connected to the Completion master port. When clear, the AXI bus is connected to an error slave to complete the failing request with an error response. Read and write channels are selected independently. If, for example, an AW translation is finished and subsequently an AR translation results in an error, we may need to have W and B channels connected to the Completion port, while R channel must remain connected to the error slave.

    The handshake with both slaves is performed with a custom AxVALID signal and the translated address. The custom AxVALID signal is set when a translation is successfully finished, or when a translation error / boundary violation occurs. Since the AXI demux should be properly connected in this case, the AxVALID signal triggers a memory transaction or an error response.

### Translation Logic

    The translation wrapper module encompasses all translation modules, connected through combinational logic. A translation is requested by setting req_trans_i.

    The first step is to perform some checks regarding the IOMMU mode and the input device_id. If everything runs well, the ddtc_access bit is set to lookup the DDTC to find the Device Context. On a hit, the ddtc_hit flag is set immediately

    A DDTC miss is signaled when the access flag is set and there is no hit. These conditions automatically trigger a CDW walk. During the walk, the translation logic remains inactive until the corresponding DC is loaded into the DDTC, setting the ddtc_hit flag.

    After locating the DC, some consistency checks are performed and it is checked if the device has associated process contexts. If it does, the pdtc_access bit is set to lookup the PDTC.

    If the device has no process contexts associated, then we have all required context information to lookup the IOTLB, so the iotlb_access bit is set.

    A PDTC miss follows the same conditions and behavior of a DDTC miss. It is not possible to perform a DDT walk and a PDT simultaneously, as DC.fsc.pdtp is required to walk the PDT, and the IOMMU processes one request at a time. On a pipelined version, the CDW would need to be modified to walk the PDT for a previously found DC, while walking the DDT for a subsequent translation request. Maybe the best option would be implementing two separate walkers.

    Once the PC is located and loaded into the PDTC, the iotlb_access bit is set to lookup the IOTLB using the tags hold by the context structures (GSCID, PSCID, translation stages, etc) and the IOVA.

    On a miss, the PTW is triggered to walk memory and load the requested mappings into the IOTLB. After this, the iotlb_hit bit is set some permission checks are performed.

    The final SPA is constructed according to the page size of the cached entry for each translation stage.

    When a request has both first and second-stage translation configured as Bare, and the associated SPA does not fulfills the conditions to be an MSI address, the SPA is bypassed. The MSI address check is performed by the PTW, but it is not triggered to walk memory

    Translation errors encounered in the wrapper module are signaled through the trans_error bit. The cause code is configured according to the error as defined by the specification. Errors may occur in PTW or CDW walks. These errors also set the trans_error bit. In these cases, the cause code is defined by the failing module.

    No walk is triggered if a previous error occurs, so it is not possible to have an error in the wrapper module and in the PTW/CDW at the same time.

    Translation errors are not always reported through the FQ. DC.tc.DTF bit filters most of the translation faults. The fault is always reported to the requesting device through the trans_error bit, but additional logic involving the DTF bit is used to determine whether it has to be reported to SW.

### Context Directory Table Caches (DDTC and PDTC)

    Lookup is performed exclusively with combinational logic with no latency. The device_id is used as a tag to index the DDTC, and both device_id and process_id are used to index entries in the PDTC.

    In both caches, invalidation is performed with higher priority than updates, so if both operations are requested at the same time, only invalidation is performed. Invalidation is also performed with combinational logic, thus, in the same clock cycle. Updates have 1-cycle latency.

    A flush request is indicated in both caches when flush_i is set. When flush_dv_i is set, all entries that match the input device_id are invalidated in both DDTC and PDTC. Otherwise, all entries are invalidated. In addition, when flush_pv_i is set, only PDTC entries matching the specified device_id and process_id are invalidated.

    A Pseudo Least-Recently Used algorithm is used to determine which entries are going to be replaced in the cache on every update. To keep track of this info, a PLRU tree is hold by each cache, and is updated on every hit and replacement.

### IO Translation Lookaside Buffer

    An IOTLB entry holds tag data and page table data for both translation stages. A unique format is used for the whole TLB, so if only one or neither translation stage is enabled for a determined entry, this hardware resources are basically wasted.

    By caching first and second-stage translations in the same IOTLB, we save comparation hardware resources, as we perform lookup, invalidation and update in the same structure.

    Lookup is performed exclusively with combinational logic in the same clock cycle, thus, zero latency. To index IOTLB entries, the following tags are used:

    - The IOVA associated with the transaction. It may be a GVA, a GPA or an SPA depending on which stages are enabled in the associated DC/PC;

    - GSCID: Address space identifier for VMs. Two different VMs may refer to the same GPA, each of them belonging to a different mapping. The GSCID tag is used to differentiate these mappings in the IOTLB. It doesn't make sense to have two devices configured with the same GSCID if they are not associated to the same page tables since the address space should be the same;

    - PSCID: Address space identifier for processes. Two different processes are associated to different address spaces, so they may refer to the same VA, but this is associated with two different mappings (two different 1st-stage page tables). Thus, the PSCID is used to differentiate these translations in the IOTLB.

    - Translation stages enable: It is possible to have two equal IOVAs, one referring to a GVA, and other referring to a GPA or an SPA. Thus, two bits are used as tags to determine which translation stages are enabled. To obtain a hit, these bits must match with the stages enabled in the corresponding DC/PC.

    Additional info is stored in the cache, but is not used to tag entries: Page size per translation stage, and a bit used to identify MSI translations.

    An effective page size is calculated based on the page size of both stages. The smaller page size is considered to be the effective page size.

    In order to obtain a hit, several matches must be obtained:

    - If first-stage translation is enabled, a PSCID match is required if the entry is not identified as global. Global entries are common to all process address spaces, thus they do not need to match the PSCID.
    - If second-stage translation is enabled, a GSCID match is required. Global entries do not exist for second-stage address translation.
    - Enabled translation stages must match with the entry tags.
    - A match finally occurs if: (i) VPN[2] matches and the effective page size is 1G; (ii) VPN[2,1] matches and the effective size of the page is 2M; or (iii) VPN[2,1,0] matches.

    Invalidation commands are received by the IOMMU through the Command Queue. All tags aforementioned are used to select entries to be invalidated. This implementation constructs the GPA to tag entries for IOTINVAL.GVMA with ADDR != 0.

    A Pseudo Least-Recently Used algorithm is used to determine which entries are going to be replaced in the cache on every update. To keep track of this info, a PLRU tree is hold by each cache, and is updated on every hit and replacement.

### Page Table Walker

    Two FSMs are used: The main FSM controls the global state of the PTW (idle, accessing memory, checking the PTE, etc). The second FSM is inside the first one, and determines the state of the memory walk. 

    The PTW can be triggered in two cases: When the IOTLB is accessed and a hit does not occur, or when the CDW requests second-stage translation, either for non-leaf PDT entries or to translate the pdtp to be saved in the DC as an SPA.

    It is externally ensured that when the CDW requests an implicit second-stage translation, stage-1 is Bare, and stage-2 is active.

    After being triggered, the PTW checks which stages are enabled, and if the input address is considered as an MSI address. The input address may be considered as MSI address if both stages are bare or if only second-stage is enabled. If no stage is enabled, and the input address is not determined to be an MSI address, the bare_translation bit is set and the FSM is not triggered.

    If both stages are enabled, the first GPA is constructed with the PPN in iosatp and the walk FSM is set to perform intermediate second-stage translation.

    If only second-stage translation is enabled, two different causes could have triggered the PTW: (i) Normal implicit second-stage translation triggered by an IOTLB miss; or (ii) an implicit translation required by the CDW when second-stage is not Bare. The address to be translated is given in a different port for each case. For normal translations, the input GPA may be an MSI address. In that case the pptr is loaded with the PPN hold in the msiptp register and a control bit is set to indicate an MSI translation.

    If only first-stage translation is enabled, the PPN in iosatp does not need to be translated by second-stage, so we can directly reference memory with the IOVA and iosatp.

    If no stage is enabled, the input address is checked to determine if it is an MSI address. If not, the bare_translation bit is set and no FSM is triggered.

    IOTLB is not updated for CDW second-stage translations. MSI translations are cached in the IOTLB as being second-stage translation data, i.e., the GPA data is the address determined as MSI and the SPA is the physical address of the guest interrupt file. If first-stage translation is enabled, it is stored as usual in the IOTLB.

    Only format checks are performed during memory walks (alignment, reserved bits set, invalid entries, etc). No permission checks are performed in the PTW. These checks are only performed in the external translation logic. This way, we update the IOLTB even if required permissions are not granted. Since the translation is still valid, we don't lose efforts by aborting IOTLB updates due to prohibited permissions. The cached translation can be further used with correct permissions.

    Errors encountered during second-stage translations requested by the CDW are reported by the PTW. The CDW receives a flush signal sent by the PTW to go back to idle state.

    The PTW indicates if the error occurred during second-stage implicit translations, and if the error was a guest-page fault.

### Context Directory Walker

    The CDW is implemented as an FSM triggered when an access to a directory cache is performed without obtaining a hit. Priority is given to DDT walks since it is not possible to walk a PDT without having found the DC.

    Multi-level tables are supported up to three levels. The number of levels is known before the walk, so we know whether the next memory access will reference a non-leaf entry or a leaf entry.

    In PDT walks, if second-stage translation is enabled, we must translate the PPN found in non-leaf entries before joining with the process_id to access memory, since these addresses are GPAs. For this purpose, the PTW is triggered to perform second-stage translation.

    Two main states are used to process leaf and non-leaf entries. NON-LEAF is triggered when we are walking the DDT and we know the next entry is non-leaf. In this case we simply update the level of the DDT and the pptr with the ppn of the received entry and the corresponding segment of the device_id. When we are walking the PDT, we can go directly to NON_LEAF when we know that the next entry is non-leaf and second-stage translation is disabled. If second-stage is enabled, we must go first to GUEST_TR to translate the PPN of the non-leaf entry.

    When we are in the last level of the table and we know that the next entry is leaf and contains either the DC or the PC, we go to LEAF. Using a counter, we check if the entire DC/PC has been loaded, continuously receiving the AXI beats from memory and storing in a register. Due to the architecture of the SoC, we can only read 64-bits at a time. 

    For DDT walks, after loading the entire DC, the CDW triggers the PTW to translate DC.fsc.pdtp, in order to save it as an SPA in the DDTC, so we don't need to translate it every time before walking the PDT. After this, the DDTC is updates with the DC. In this case, we forward the PPN of iohgatp to the PTW, since the DDTC has not been updated yet. For PDT walks, the PDTC is instantly updated after having the entire PC loaded.

    Since AXI transactions involving multiple beats (Burst type INCR) can not be aborted earlier, we ensure that the transaction is finished and all beats discarded setting the RREADY signal until receiving RLAST in case of error.