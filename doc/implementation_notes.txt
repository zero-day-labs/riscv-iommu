*   IO Access Arbitration Logic

    The IO Access Arbitration logic uses stream arbiters for AR and AW Channels. As requests are accepted, the ID of devices requesting write is stored in a FIFO to select the correct W channel, since write bursts are not identified by a WID signal.

    It is not necessary to store the ID of devices requesting to read, as incoming streams through R channel are identified by RID. The same occurs for the write response channel (B).

    Input channels (R, B) use stream demuxes to perform an AXI handshake (only VALID/READY signals) with the correct device. Remaining R and B input signals are directly connected for each device to the output master port.

    If two devices perform requests of different type (r/w) at the same time, these requests reach the output port independently, since involved channels are independent

    If two or more devices perform requests of the same type at the same time, the stream arbiter selects only one at a time. AXI requests naturally remain active until a handshake occurs (blocking). For AW requests, the AWID is saved in a FIFO to forward the write data through the corresponding W channel.

*   Translation Requests

    The output of the IO Access Arbitration module is connected to the Translation Request IF of the IOMMU. Two translation requests may arrive at the same time if they are from different types (r/w). However, the IOMMU processes only one request at a time (priority is given to read requests).

    The AxVALID signal triggers the channel selection logic. When having a read request and a write request pending at the same time, the write request holds until the translation for the read request is completed and no other device has a read request pending. May need to alternate priorities.

    Another bit is set for the selected request, triggering the boundary check logic to guarantee that the transaction won't cross a 4kiB address boundary, which is prohibited by the AXI standard. This logic sets a unified allow_request bit if no address boundary violation is detected. Otherwise, a unified boundary_violation bit is set.

    The allow_request bit triggers the translation logic, which can successfully perform the address translation setting the trans_valid bit, or an error may occur and the trans_error bit is set.

    The trans_valid bit selects the AXI slave to which the bus is connected. When set, the AXI bus is connected to the Completion master port. When clear, the AXI bus is connected to an error slave to complete the failing request with an error response. Read and write channels are selected independently. If, for example, an AW translation is finished and subsequently an AR translation results in an error, we may need to have W and B channels connected to the Completion port, while R channel must remain connected to the error slave.

    The handshake with both slaves is performed with a custom AxVALID signal and the translated address. The custom AxVALID signal is set when a translation is successfully finished, or when a translation error / boundary violation occurs. Since the AXI demux should be properly connected in this case, the AxVALID signal triggers a memory transaction or an error response.

*   Translation Logic

    The translation wrapper module encompasses all translation modules, connected through combinational logic. A translation is requested by setting req_trans_i.

    The first step is to perform some checks regarding the IOMMU mode and the input device_id. If everything runs well, the ddtc_access bit is set to lookup the DDTC to find the Device Context. On a hit, the ddtc_hit flag is set immediately

    A DDTC miss is signaled when the access flag is set and there is no hit. These conditions automatically trigger a CDW walk. During the walk, the translation logic remains inactive until the corresponding DC is loaded into the DDTC, setting the ddtc_hit flag.

    After locating the DC, some consistency checks are performed and it is checked if the device has associated process contexts. If it does, the pdtc_access bit is set to lookup the PDTC.

    If the device has no process contexts associated, then we have all required context information to lookup the IOTLB, so the iotlb_access bit is set.

    A PDTC miss follows the same conditions and behavior of a DDTC miss. It is not possible to perform a DDT walk and a PDT simultaneously, as DC.fsc.pdtp is required to walk the PDT, and the IOMMU processes one request at a time. On a pipelined version, the CDW would need to be modified to walk the PDT for a previously found DC, while walking the DDT for a subsequent translation request. Maybe the best option would be implementing two separate walkers.

    Once the PC is located and loaded into the PDTC, the iotlb_access bit is set to lookup the IOTLB using the tags hold by the context structures (GSCID, PSCID, translation stages, etc) and the IOVA.

    On a miss, the PTW is triggered to walk memory and load the requested mappings into the IOTLB. After this, the iotlb_hit bit is set some permission checks are performed.

    The final SPA is constructed according to the page size of the cached entry for each translation stage.

    When a request has both first and second-stage translation configured as Bare, and the associated SPA does not fulfills the conditions to be an MSI address, the SPA is bypassed. The MSI address check is performed by the PTW, but it is not triggered to walk memory

    Translation errors encounered in the wrapper module are signaled through the trans_error bit. The cause code is configured according to the error as defined by the specification. Errors may occur in PTW or CDW walks. These errors also set the trans_error bit. In these cases, the cause code is defined by the failing module.

    No walk is triggered if a previous error occurs, so it is not possible to have an error in the wrapper module and in the PTW/CDW at the same time.

    Translation errors are not always reported through the FQ. DC.tc.DTF bit filters most of the translation faults. The fault is always reported to the requesting device through the trans_error bit, but additional logic involving the DTF bit is used to determine whether it has to be reported to SW.