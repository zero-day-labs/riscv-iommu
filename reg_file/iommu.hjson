# TODO: Check what's better for permissions for the registers (for SW and HW). Also check for reset values.
# For WARL registers, the appropriate access behavior may be implemented with RW HWExt and external logic. This way, the register value is maintained outside the auto-generated logic


{
	name: "iommu",
    // clocking: [{clock: "clk_i", reset: "nrst_i"}],
	// bus_interfaces: [{
	//     protocol: "tlul",
	//     direction: "device"
    // }],
    clock_primary: "clk_i",
	reset_primary: "nrst_i",
	bus_interfaces: [{
	    protocol: "reg_iface",
	    direction: "device"
    }],
    regwidth: "64",
	registers: [
    {
        # Capabilities register. Set fields indicate presence of that feature in the IOMMU.
        # Field reset values shall contain IOMMU supported features.
        name: "capabilities",
        desc: "Read-only register reporting features supported by the IOMMU.",
        swaccess: "ro", // Read only for all register fields
        hwaccess: "hro",
        fields: [
        {
            bits: "7:0",
            name: "version",
            desc: "Version of the spec implemented by the IOMMU.",
            resval: "16" // MS nibble indicates the major version number, LS nibble indicates the minor version number
        }
        {
            bits: "8",
            name: "Sv32",
            desc: "Page-based 32-bit addressing is supported.",
            resval: "1" // TODO: Check if Sv32 is actually implemented
        }
        {
            bits: "9",
            name: "Sv39",
            desc: "Page-based 39-bit addressing is supported.",
            resval: "1" // CVA6 uses Sv39
        }
        {
            bits: "10",
            name: "Sv48",
            desc: "Page-based 48-bit addressing is supported.",
            resval: "0"
        }
        {
            bits: "11",
            name: "Sv57",
            desc: "Page-based 57-bit addressing is supported.",
            resval: "0"
        }
        {
            bits: "14",
            name: "Svnapot",
            desc: "NAPOT translation contiguity is supported.",
            resval: "0" // not supported for first iteration
        }
        {
            bits: "15",
            name: "Svpbmt",
            desc: "Page-Based Memory Types are supported by the IOMMU.",
            resval: "0"
        }
        {
            bits: "16",
            name: "Sv32x4",
            desc: "Page-based 34-bit virtual addressing for G-stage translation is supported.",
            resval: "1" // TODO: Check if Sv32x4 is actually implemented
        }
        {
            bits: "17",
            name: "Sv39x4",
            desc: "Page-based 41-bit virtual addressing for G-stage translation is supported.",
            resval: "1" // CVA6 uses Sv39
        }
        {
            bits: "18",
            name: "Sv48x4",
            desc: "Page-based 50-bit virtual addressing for G-stage translation is supported.",
            resval: "0"
        }
        {
            bits: "19",
            name: "Sv57x4",
            desc: "Page-based 59-bit virtual addressing for G-stage translation is supported.",
            resval: "0"
        }
        {
            bits: "22",
            name: "MSI_FLAT",
            desc: "MSI address translation using Write-through mode MSI PTE is supported.", // TODO: May be changed to 'Pass-through mode'?
            resval: "1"     // MSI redirection will be supported in first iteration
        }
        {
            bits: "23",
            name: "MSI_MRIF",
            desc: "MSI address translation using MRIF mode MSI PTE is supported.",
            resval: "0"     // not implemented in first iteration
        }
        {
            bits: "24",
            name: "AMO",
            desc: "Atomic updates to MRIF and PTE accessed (A) and dirty (D) bit is supported.",
            resval: "0"     // not implemented in the first iteration
        }
        {
            bits: "25",
            name: "ATS",
            desc: "PCIe Address Translation Services (ATS) and page-request interface (PRI) is supported.",
            resval: "0"     // not implemented in the first iteration
        }
        {
            bits: "26",
            name: "T2GPA",
            desc: "Returning guest-physical-address in ATS translation completions is supported.",
            resval: "0"     // Since ATS will not be implemented in the first iteration, T2GPA will be zero
        }
        {
            bits: "27",
            name: "END",
            desc: '''
                When 0, IOMMU supports one endianness (either little or big). When 1, IOMMU supports both endianness. 
                The endianness is defined in fctl register.
            ''',
            resval: "0"     // TODO: Check this. May be implemented in the second iteration
        }
        {
            bits: "29:28",
            name: "IGS",
            resval: "0",     // TODO: Check this. May be implementes in the second iteration
            desc: "IOMMU interrupt generation support.",
            enum: [
                { value: "0", name: "MSI", desc: "IOMMU supports only MSI generation." },
                { value: "1", name: "WSI", desc: "IOMMU supports only WSI generation." },
                { value: "2", name: "BOTH", desc: "IOMMU supports both MSI and WSI generation. The chosen method must be defined in the fctl register." },
                { value: "3", name: "zero", desc: "Reserved for standard use." }
            ]
        }
        {
            bits: "30",
            name: "HPM",
            desc: "IOMMU implements a hardware performance monitor.",
            resval: "0"     // To be implemented in the second iteration
        }
        {
            bits: "31",
            name: "DBG",
            desc: "IOMMU supports a debug translation-request interface.",
            resval: "0"     // may be implemented in a second iteration
        }
        {
            bits: "37:32",
            name: "PAS",
            desc: "Physical Address Size (value between 32 and 56)"     // 34 bits for Sv32. 56 bits for Sv39, Sv48 and Sv57
            resval: "32"     // TODO: check which will be the translation scheme by default
        }
        {
            bits: "38",
            name: "PD8",
            desc: "One level PDT with 8-bit process_id supported for indexing.",
            resval: "1"     // TODO: check for default process_id length
        }
        {
            bits: "39",
            name: "PD17",
            desc: "Two level PDT with 17-bit process_id supported for indexing.",
            resval: "0" 
        }
        {
            bits: "40",
            name: "PD20",
            desc: "Three level PDT with 20-bit process_id supported for indexing.",
            resval: "0"
        }
        ]
    },
    {
        # Features-control register. Some fields in this register may be written to enable/disable any feature.
        # ATTENTION: If software enables or disables any feature when the IOMMU is not OFF, or when in-memory queues are enabled, 
        # the behavior is UNSPECIFIED.
        #
        # WARL behavior is implemented as rw. Any read value will be the last value written to the register (ONLY IF LEGAL).
        # WPRI behavior may be implemented as fields hardwired to zero.
        name: "fctl",
        desc: "Features-control register. Some fields in this register may be written to enable/disable any feature.",
        swaccess: "rw",     // WARL by default. After generating RTL check logic for illegal situations.
        hwaccess: "hrw",
        fields: [
        {
            bits: "0",
            name: "BE",
            desc: "When set to 1, accesses to in-memory data structures are performed as Big-endian. When 0, accessed are performed as little-endian.",
            resval: "0" // Must be consistent with END bit of capabilities register. No WARL illegal situations i think...
        }
        {
            bits: "1",
            name: "WSI",
            desc: "When set to 1, all IOMMU interrupts are signaled as WSI. Otherwise, interrupts are signaled as MSI.",
            resval: "0" // Must be consistent with IGS bit of capabilities register. 
                        // There is no sense in seting WSI to 1 when the IOMMU does not support WSI interrupts. Same for the opposite situation
        }
        {
            bits: "2",
            name: "ADFD",
            desc: '''
                When 1, IOMMU faults due to A/D bits is disabled, as well as updates to these bits. 
                When 0, the IOMMU causes G-stage or V/VS-stage page faults due to A/D bits
                ''',
            resval: "1" // Must be consistent with AMO bit of capabilities register.
                        // If AMO are not supported, the IOMMU can not update A/D bits, so ADFD can not be 0
        }
        ]
    },
    {reserved: "1"},
    {
        # Device-Directory Table Pointer. Used to index the Device Directory Table
        #
        # WARL behavior is implemented as rw. Any read value will be the last value written to the register (ONLY IF LEGAL).
        name: "ddtp",
        desc: "Device-Directory Table Pointer. Used to index the Device Directory Table.",
        fields: [
        {
            bits: "3:0",
            name: "iommu_mode",
            desc: "IOMMU overall mode. It may support one of the following modes:",
            resval: "0",    // TODO: Should be set by default to zero ???
            swaccess: "rw", // ATTENTION: Writes must be checked so any value greater than 4 is written to the register.
            hwaccess: "hrw",
            enum: [
                { value: "0", name: "Off", desc: "No inbound memory transactions are allowed in the IOMMU." },
                { value: "1", name: "Bare", desc: "No translation/protection. All inbound memory accesses are passed through." },
                { value: "2", name: "1LVL", desc: "One-level device-directory table." },
                { value: "3", name: "2LVL", desc: "Two-level device-directory table." },
                { value: "4", name: "3LVL", desc: "Three-level device-directory table." }
            ]
        }
        {
            bits: "4",
            name: "busy",
            desc: '''
                When set to 1, indicates that a write to the ddtp was performed. When the ddtp is written, the IOMMU may need to perform 
                some operations. Unitl these operations are not concluded, the behavior of additional writes to the ddtp is unspecified.
            ''',
            swaccess: "ro",
            hwaccess: "hrw",
            resval: "0"
        }
        {
            bits: "53:10",
            name: "PPN",
            desc: "Physical Page Number of the root page of the DDT.",
            resval: "0",
            swaccess: "rw",  // Same: since this field is WARL, writes must be checked
            hwaccess: "hrw" 
        }
        ]
    },
    {
        # Command-queue base register: Holds the PPN of the root page of the CQ, and number of entries in it.
        #
        # WARL behavior is implemented as rw. Any read value will be the last value written to the register (ONLY IF LEGAL).
        name: "cqb",
        desc: "Command-queue base register. Holds the PPN of the root page of the CQ, and number of entries in it.",
        fields: [
        {
            bits: "4:0",
            name: "LOG2SZ_1",
            desc: '''
                Number of entries in the CQ, expressed as LOG to base 2 minus 1. 
                When the CQ has 256 or less entries (LOG2SZ <= 7), the base address of the queue is aligned to 4 KiB.
                Otherwise, the base address must be naturally aligned to 2^LOG2SZ x 16.
            ''',    // 2 entries => 0; 4 entries => 1; etc. Aligned to 4-KiB => PPN = 0xn000.
            resval: "0",
            swaccess: "rw",  // Same: since this field is WARL, writes must be checked
            hwaccess: "hrw" 
        }
        {
            bits: "53:10",
            name: "PPN",
            desc: '''
                Physical Page Number of the root page of the in-memory CQ used by SW to queue commands to the IOMMU.
                If this base address is not aligned as required, behavior when interacting with the CQ is unspecified.
            ''',
            resval: "0",
            swaccess: "rw",  // Same: since this field is WARL, writes must be checked
            hwaccess: "hrw" 
        }
        ]
    },
    {
        # Command-queue head: Holds the index into the command-queue where the IOMMU will fetch the next command.
        name: "cqh",
        desc: "Command-queue head: Holds the index into the command-queue where the IOMMU will fetch the next command.",
        swaccess: "ro",
        hwaccess: "hrw",
        fields: [
        {
            bits: "31:0",
            name: "index",
            desc: '''
                Holds the index into the command-queue from where the next command will be fetched next by the IOMMU.
            ''',
            resval: "0"
        }
        ]
    },
    {
        # Command-queue tail: holds the index into the command-queue where the software queues the next command for the IOMMU.
        name: "cqt",
        desc: "Command-queue tail: holds the index into the command-queue where the software queues the next command for the IOMMU.",
        swaccess: "rw",
        hwaccess: "hrw",
        fields: [
        {
            bits: "31:0",
            name: "index",
            desc: '''
                Holds the index into the command-queue from where the next command will be fetched next by the IOMMU.
            ''',
            resval: "0"
        }
        ]
    },
    {
        # Fault queue base register: Holds the PPN of the root page of the FQ, and number of entries in it.
        #
        # WARL behavior is implemented as rw. Any read value will be the last value written to the register (ONLY IF LEGAL).
        name: "fqb",
        desc: "Fault queue base register. Holds the PPN of the root page of the FQ, and number of entries in it.",
        fields: [
        {
            bits: "4:0",
            name: "LOG2SZ_1",
            desc: '''
                Number of entries in the FQ, expressed as LOG to base 2 minus 1. 
                When the FQ has 128 or less entries (LOG2SZ <= 6), the base address of the queue is aligned to 4 KiB.
                Otherwise, the base address must be naturally aligned to 2^LOG2SZ x 32.
            ''',    // 2 entries => 0; 4 entries => 1; etc. Aligned to 4-KiB => PPN = 0xn000.
            resval: "0",
            swaccess: "rw",  // Same: since this field is WARL, writes must be checked
            hwaccess: "hrw" 
        }
        {
            bits: "53:10",
            name: "PPN",
            desc: '''
                Physical Page Number of the root page of the in-memory FQ used by the IOMMU to queue fault record.
                If this base address is not aligned as required, behavior when interacting with the FQ is unspecified.
            ''',
            resval: "0",
            swaccess: "rw",  // Same: since this field is WARL, writes must be checked
            hwaccess: "hrw" 
        }
        ]
    },
    {
        # Fault queue head: Holds the index into the fault queue where the SW will fetch the next fault record.
        name: "fqh",
        desc: "Fault queue head: Holds the index into the command-queue where the SW will fetch the next fault record.",
        swaccess: "rw",     // ATTENTION: The write constraint referred in the description must be fulfilled
        hwaccess: "hrw",
        fields: [
        {
            bits: "31:0",
            name: "index",
            desc: '''
                Holds the index into the fault-queue from which software reads the next fault record. Only LOG2SZ-1:0 bits are writable.
            ''',
            resval: "0"
        }
        ]
    },
    {
        # Fault queue tail: holds the index into the fault queue where the IOMMU queues the next fault record for the SW.
        name: "fqt",
        desc: "Fault queue tail: holds the index into the fault queue where the IOMMU queues the next fault record for the SW.",
        swaccess: "ro",
        hwaccess: "hrw",
        fields: [
        {
            bits: "31:0",
            name: "index",
            desc: '''
                Holds the index into the fault-queue where IOMMU writes the next fault record.
            ''',
            resval: "0"
        }
        ]
    },
    // {
    //     # Page-request queue base register: Holds the PPN of the root page of the PQ, and number of entries in it.
    //     #
    //     # WARL behavior is implemented as rw. Any read value will be the last value written to the register (ONLY IF LEGAL).
    //     name: "pqb",
    //     desc: "Page-request queue base register: Holds the PPN of the root page of the PQ, and number of entries in it.",
    //     fields: [
    //     {
    //         bits: "4:0",
    //         name: "LOG2SZ_1",
    //         desc: '''
    //             Number of entries in the PQ, expressed as LOG to base 2 minus 1. 
    //             When the PQ has 256 or less entries (LOG2SZ <= 7), the base address of the queue is aligned to 4 KiB.
    //             Otherwise, the base address must be naturally aligned to 2^LOG2SZ x 16.
    //         ''',    // 2 entries => 0; 4 entries => 1; etc. Aligned to 4-KiB => PPN = 0xn000.
    //         resval: "0",
    //         swaccess: "rw",  // Same: since this field is WARL, writes must be checked
    //         hwaccess: "hrw" 
    //     }
    //     {
    //         bits: "53:10",
    //         name: "PPN",
    //         desc: '''
    //             Physical Page Number of the root page of the in-memory PQ used by the IOMMU to queue page-request messages.
    //             If this base address is not aligned as required, behavior when interacting with the PQ is unspecified.
    //         ''',
    //         resval: "0",
    //         swaccess: "rw",  // Same: since this field is WARL, writes must be checked
    //         hwaccess: "hrw" 
    //     }
    //     ]
    // },
    // {
    //     # Page-request queue head: Holds the index into the page-request queue where the SW will fetch the next page request.
    //     name: "pqh",
    //     desc: "Page-request queue head: Holds the index into the page-request queue where the SW will fetch the next page request.",
    //     swaccess: "rw",     // ATTENTION: The write constraint referred in the description must be fulfilled
    //     hwaccess: "hrw",
    //     fields: [
    //     {
    //         bits: "31:0",
    //         name: "index",
    //         desc: '''
    //             Holds the index into the page-request-queue from which software reads the next "Page Request" message. 
    //             Only LOG2SZ-1:0 bits are writable.
    //         ''',
    //         resval: "0"
    //     }
    // },
    // {
    //     # Page-request queue tail: holds the index into the page-request queue where the IOMMU queues the next page-request message for the SW.
    //     name: "pqt",
    //     desc: "Page-request queue tail: holds the index into the page-request queue where the IOMMU queues the next page-request message for the SW.",
    //     swaccess: "ro",
    //     hwaccess: "hrw",
    //     fields: [
    //     {
    //         bits: "31:0",
    //         name: "index",
    //         desc: '''
    //             Holds the index into the page-request-queue where IOMMU writes the next "Page Request" message.
    //         ''',
    //         resval: "0"
    //     }
    //     ]
    // },
    { reserved: "2" }, // skip PQ regs (capabilities.ATS = 0)
    {
        # Command Queue CSR
        name: "cqcsr",
        desc: "Command Queue CSR: controls the operations and report the status of the command-queue.",
        fields: [
        {
            bits: "0",
            name: "cqen",
            desc: '''
                The command-queue-enable bit enables the command-queue when set to 1. Changing cqen from 0 to 1 sets the cqh and cqt to 0.
                See specs for more details on CQ activation or deactivation.
            ''',
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        {
            bits: "1",
            name: "cie",
            desc: '''
                Command-queue-interrupt-enable bit enables generation of interrupts from command-queue when set to 1.
            ''',
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        {
            bits: "8",
            name: "cqmf",
            desc: '''
                Indicates a memory fault due to a CQ access. If command-queue access leads to a memory fault then 
                the command-queue-memory-fault bit is set to 1 and the command-queue stalls until this bit is cleared.
                More details about system behavior in specs.
            ''',
            resval: "0",
            swaccess: "rw1c",
            hwaccess: "hrw"
        }
        {
            bits: "9",
            name: "cmd_to",
            desc: '''
                Indicates timeout after a command execution, for example waiting for a completion/response.
                If the execution of a command leads to a timeout, then the command-queue sets the cmd_to bit and 
                stops processing from the command-queue. More details in specs.
            ''',
            resval: "0",
            swaccess: "rw1c",
            hwaccess: "hrw"
        }
        {
            bits: "10",
            name: "cmd_ill",
            desc: '''
                If an illegal or unsupported command is fetched and decoded by the command-queue,
                then the command-queue sets the cmd_ill bit and stops processing from the command-queue. 
                More details in specs.
            ''',
            resval: "0",
            swaccess: "rw1c",
            hwaccess: "hrw"
        }
        {
            bits: "11",
            name: "fence_w_ip",
            desc: '''
                An IOMMU that supports only wire-signaled-interrupts sets fence_w_ip bit is set to indicate completion of an IOFENCE.C command.
                More details in specs.
            ''',
            resval: "0",
            swaccess: "rw1c",
            hwaccess: "hrw"
        }
        {
            bits: "16",
            name: "cqon",
            desc: '''
                The command-queue is functionally active if cqon is 1. IOMMU behavior on changing cqb when busy is 1 or cqon is 1 is unspecified.
                More details in specs.
            ''',
            resval: "0",
            swaccess: "ro",
            hwaccess: "hrw"
        }
        {
            bits: "17",
            name: "busy",
            desc: '''
                A write to cqcsr may require the IOMMU to perform many operations that may not occur synchronously to the write. 
                When a write is observed by the cqcsr, the busy bit is set to 1. More details in specs.
            ''',
            resval: "0",
            swaccess: "ro",
            hwaccess: "hrw"
        }
        ]
    },
    {
        # Fault Queue CSR
        name: "fqcsr",
        desc: "Fault Queue CSR: controls the operations and report the status of the fault queue.",
        fields: [
        {
            bits: "0",
            name: "fqen",
            desc: '''
                The fault-queue-enable bit enables the fault-queue when set to 1. Changing fqen from 0 to 1 sets the fqh and fqt to 0.
                See specs for more details on FQ activation or deactivation.
            ''',
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        {
            bits: "1",
            name: "fie",
            desc: '''
                Fault-queue-interrupt-enable bit enables generation of interrupts from fault-queue when set to 1.
            ''',
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        {
            bits: "8",
            name: "fqmf",
            desc: '''
                The fqmf bit is set to 1 if the IOMMU encounters an access fault when storing a fault record to the fault queue. 
                The fault-record that was attempted to be written is discarded and no more fault records are generated until 
                software clears fqmf bit by writing 1 to the bit. More details in the specs.
            ''',
            resval: "0",
            swaccess: "rw1c",
            hwaccess: "hrw"
        }
        {
            bits: "9",
            name: "fqof",
            desc: '''
                The fault-queue-overflow bit is set to 1 if the IOMMU needs to queue a fault record but the fault-queue is full.
            ''',
            resval: "0",
            swaccess: "rw1c",
            hwaccess: "hrw"
        }
        {
            bits: "16",
            name: "fqon",
            desc: '''
                The fault-queue is active if fqon reads 1. IOMMU behavior on changing fqb when busy is 1 or fqon is 1 is UNSPECIFIED.
                More details in specs.
            ''',
            resval: "0",
            swaccess: "ro",
            hwaccess: "hrw"
        }
        {
            bits: "17",
            name: "busy",
            desc: '''
                Writes to fqcsr may require the IOMMU to perform many operations that may not occur synchronously to the write.
                When a write is observed by the fqcsr, the busy bit is set to 1. More details in specs.
            ''',
            resval: "0",
            swaccess: "ro",
            hwaccess: "hrw"
        }
        ]
    },
    // {
    //     # Page-Request Queue CSR
    //     name: "pqcsr",
    //     desc: "Page-Request Queue CSR: controls the operations and report the status of the PR queue.",
    //     fields: [
    //     {
    //         bits: "0",
    //         name: "pqen",
    //         desc: '''
    //             The fault-queue-enable bit enables the fault-queue when set to 1. 
    //             Changing pqen from 0 to 1, resets the pqh and pqt to 0 and clears pqcsr bits pqmf and pqof to 0.
    //             See specs for more details on FQ activation or deactivation.
    //         ''',
    //         resval: "0",
    //         swaccess: "rw",
    //         hwaccess: "hrw"
    //     }
    //     {
    //         bits: "1",
    //         name: "pie",
    //         desc: '''
    //             Page-request-queue-interrupt-enable bit enables generation of interrupts from PR-queue when set to 1.
    //         ''',
    //         resval: "0",
    //         swaccess: "rw",
    //         hwaccess: "hrw"
    //     }
    //     {
    //         bits: "8",
    //         name: "pqmf",
    //         desc: '''
    //             The pqmf bit is set to 1 if the IOMMU encounters an access fault when storing a 
    //             page-request message to the page-request-queue. More details in the specs.
    //         ''',
    //         resval: "0",
    //         swaccess: "rw1c",
    //         hwaccess: "hrw"
    //     }
    //     {
    //         bits: "9",
    //         name: "pqof",
    //         desc: '''
    //             The page-request-queue-overflow bit is set to 1 if the page-request queue overflows.
    //         ''',
    //         resval: "0",
    //         swaccess: "rw1c",
    //         hwaccess: "hrw"
    //     }
    //     {
    //         bits: "16",
    //         name: "pqon",
    //         desc: '''
    //             The PR-queue is active if pqon reads 1. IOMMU behavior on changing pqb when busy is 1 or pqon is 1 is UNSPECIFIED.
    //             More details in specs.
    //         ''',
    //         resval: "0",
    //         swaccess: "ro",
    //         hwaccess: "hrw"
    //     }
    //     {
    //         bits: "17",
    //         name: "busy",
    //         desc: '''
    //             Writes to pqcsr may require the IOMMU to perform many operations that may not occur synchronously to the write.
    //             When a write is observed by the pqcsr, the busy bit is set to 1. More details in specs.
    //         ''',
    //         resval: "0",
    //         swaccess: "ro",
    //         hwaccess: "hrw"
    //     }
    //     ]
    // }
    {reserved: "1"},    // skip PQ CSR reg (capabilities.ATS = 0)
    {
        # Interrupt pending status register
        name: "ipsr",
        desc: '''
            Interrupt Pending Status Register: This 32-bits register reports the pending interrupts which require software service. 
            Each interrupt-pending bit in the register corresponds to a interrupt source in the IOMMU.
        ''',
        swaccess: "rw1c",
        hwaccess: "hrw",
        fields: [
        {
            bits: "0",
            name: "cip",
            desc: "Command Queue interrupt pending bit.",
            resval: "0"
        }
        {
            bits: "1",
            name: "fip",
            desc: "Fault Queue interrupt pending bit.",
            resval: "0"
        }
        {
            bits: "2",
            name: "pmip",
            desc: "Performance Monitoring Unit interrupt pending bit.",
            resval: "0"
        }
        {
            bits: "3",
            name: "pip",
            desc: "Page Request Queue interrupt pending bit.",      // May be unused
            resval: "0"
        }
        ]
    },
    // {
    //     # Performance-monitoring counter overflow status
    //     name: "iocountovf",
    //     desc: '''
    //         The performance-monitoring counter overflow status is a 32-bit read-only register that contains 
    //         shadow copies of the OF bits in the HPM counter registers.
    //     ''',
    //     swaccess: "ro",
    //     hwaccess: "hrw",
    //     fields: [
    //     {
    //         bits: "0",
    //         name: "CY",
    //         desc: "Shadow of iohpmcycles.OF.",
    //         resval: "0"
    //     }
    //     {
    //         bits: "31:1",
    //         name: "HPM",
    //         desc: "Shadow of iohpmevt[1-31].OF",
    //         resval: "0"
    //     }
    //     ]
    // },
    // {
    //     # Performance-monitoring counter inhibits/disable
    //     name: "iocountinh",
    //     desc: '''
    //         The performance-monitoring counter inhibits is a 32-bits WARL register that contains bits to 
    //         inhibit the corresponding counters from counting.
    //     ''',
    //     swaccess: "rw",
    //     hwaccess: "hrw",
    //     fields: [
    //     {
    //         bits: "0",
    //         name: "CY",
    //         desc: "When set, iohpmcycles counter is inhibited from counting.",
    //         resval: "0"
    //     }
    //     {
    //         bits: "31:1",
    //         name: "HPM",
    //         desc: "When bit X is set, then counting of events in iohpmctrX is inhibited.",
    //         resval: "0"
    //     }
    //     ]
    // },
    // {
    //     # Performance-monitoring cycles counter
    //     name: "iohpmcycles",
    //     desc: '''
    //         Free running clock cycle counter. 
    //         When capabilities.HPM is set, the iohpmcycles register must be present and be at least a 32-bits wide.
    //     ''',
    //     swaccess: "rw",
    //     hwaccess: "hrw",
    //     fields: [
    //     {
    //         bits: "62:0",
    //         name: "counter",
    //         desc: "Cycles counter value.",
    //         resval: "0"
    //     }
    //     {
    //         bits: "63",
    //         name: "OF",
    //         desc: "Overflow bit.",
    //         resval: "0"
    //     }
    //     ]
    // },
    // {
    //     # Performance-monitoring event counters
    //     multireg: {
    //         name: "iohpmctr",
    //         desc: "Performance-monitoring event counters.",
    //         count: "31",
    //         cname: "iohpmctr",
    //         swaccess: "rw",
    //         hwaccess: "hrw",
    //         fields: [
    //         {   
    //             bits: "63:0",
    //             name: "counter", 
    //             resval: "0",
    //             desc: "Event counter value."
    //         }
    //         ]
    //     }
    // },
    // {
    //     # Performance-monitoring event selectors
    //     multireg: {
    //         name: "iohpmevt",
    //         desc: "Performance-monitoring event selectors.",
    //         count: "31",
    //         cname: "iohpmevt",
    //         swaccess: "rw",
    //         hwaccess: "hrw",
    //         fields: [
    //         {   
    //             bits: "14:0",
    //             name: "eventID",
    //             resval: "0",
    //             desc: '''
    //                 Indicates the event to count. A value of 0 indicates no events are counted. 
    //                 Encoding 1 to 16383 are reserved for standard events. 
    //                 Encoding 16384 to 32767 are for designated for custom use.
    //             '''
    //         }
    //         {   
    //             bits: "15",
    //             name: "DMASK",
    //             resval: "0",
    //             desc: '''
    //                 When set to 1, partial matching of the DID_GSCID is performed for the transaction. 
    //                 The lower bits of the DID_GSCID all the way to the first low order 0 bit are masked.
    //             '''
    //         }
    //         {   
    //             bits: "35:16",
    //             name: "PID_PSCID",
    //             resval: "0",
    //             desc: '''
    //                 process_id if IDT is 0, PSCID if IDT is 1.
    //             '''
    //         }
    //         {   
    //             bits: "59:36",
    //             name: "DID_GSCID",
    //             resval: "0",
    //             desc: '''
    //                 device_id if IDT is 0, GSCID if IDT is 1.
    //             '''
    //         }
    //         {   
    //             bits: "60",
    //             name: "PV_PSCV",
    //             resval: "0",
    //             desc: '''
    //                 If set, only transactions with matching process_id or PSCID (based on the Filter ID Type) are counted.
    //             '''
    //         }
    //         {   
    //             bits: "61",
    //             name: "DV_GSCV",
    //             resval: "0",
    //             desc: '''
    //                 If set, only transactions with matching device_id or GSCID (based on the Filter ID Type) are counted.
    //             '''
    //         }
    //         {   
    //             bits: "62",
    //             name: "IDT",
    //             resval: "0",
    //             desc: '''
    //                 Filter ID Type: This field indicates the type of ID to filter on. 
    //                 When 0, the DID_GSCID field holds a device_id and the PID_PSCID field holds a process_id.
    //                 When 1, the DID_GSCID field holds a GSCID and PID_PSCID field holds a PSCID.
    //             '''
    //         }
    //         {   
    //             bits: "63",
    //             name: "OF",
    //             resval: "0",
    //             desc: '''
    //                 Overflow status or Interrupt disable.
    //             '''
    //         }
    //         ]
    //     }
    // },
    {reserved: "64"},  // skip HPM registers (capabilities.HPM = 0)
    // {
    //     # Translation Request IOVA
    //     name: "tr_req_iova",
    //     desc: '''
    //         64-bit WARL register used to implement a translation-request interface for debug.
    //     ''',
    //     swaccess: "rw",
    //     hwaccess: "hrw",
    //     fields: [
    //     {
    //         bits: "11:0",
    //         name: "pgoff",
    //         desc: "The IOVA page-offset.",
    //         resval: "0"
    //     }
    //     {
    //         bits: "63:12",
    //         name: "iova_vpn",
    //         desc: "The IOVA virtual page number.",
    //         resval: "0"
    //     }
    //     ]
    // },
    // {
    //     # Translation Request Control
    //     name: "tr_req_ctl",
    //     desc: '''
    //         64-bit WARL register used to implement a translation-request interface for debug.
    //     ''',
    //     swaccess: "rw",
    //     hwaccess: "hrw",
    //     fields: [
    //     {
    //         bits: "0",
    //         name: "Go/Busy",
    //         desc: "This bit is set to indicate a valid request has been setup in the tr_req_iova/tr_req_ctl registers for the IOMMU to translate.",
    //         resval: "0",
    //         swaccess: "rw1s"
    //     }
    //     {
    //         bits: "1",
    //         name: "Priv",
    //         desc: "When set to 1 the requests needs Privileged Mode access for this translation.",
    //         resval: "0"
    //     }
    //     {
    //         bits: "2",
    //         name: "Exe",
    //         desc: "When set to 1 the request needs execute access for this translation.",
    //         resval: "0"
    //     }
    //     {
    //         bits: "3",
    //         name: "RWn",
    //         desc: "When set to 1 the request only needs read-only access for this translation.",
    //         resval: "0"
    //     }
    //     // skip reserved space [11:4]
    //     {
    //         bits: "31:12",
    //         name: "PID",
    //         desc: "When PV is 1 this field provides the process_id for this translation request.",
    //         resval: "0"
    //     }
    //     {
    //         bits: "32",
    //         name: "PV",
    //         desc: "When set to 1 the PID field of the register is valid.",
    //         resval: "0"
    //     }
    //     // skip reserved and custom fields
    //     {
    //         bits: "63:40",
    //         name: "DID",
    //         desc: "This field provides the device_id for this translation request.",
    //         resval: "0"
    //     }
    //     ]
    // },
    // {
    // {
    //     # Translation Response
    //     name: "tr_response",
    //     desc: '''
    //         64-bit RO register used to hold the results of a translation requested using the translation-request interface.
    //     ''',
    //     swaccess: "ro",
    //     hwaccess: "hrw",
    //     fields: [
    //     {
    //         bits: "0",
    //         name: "fault",
    //         desc: '''
    //             If the process to translate the IOVA detects a fault then the fault field is set to 1.
    //             The detected fault may be reported through the fault-queue.
    //         ''',
    //         resval: "0"
    //     }
    //     // skip reserved bits
    //     {
    //         bits: "8:7",
    //         name: "PBMT",
    //         desc: '''
    //             Memory type determined for the translation using the PBMT fields in the S/VS-stage 
    //             and/or the G-stage page tables used for the translation.
    //         ''',
    //         resval: "0"
    //     }
    //     {
    //         bits: "9",
    //         name: "S",
    //         desc: '''
    //             Translation range size field, when set to 1 indicates that the translation 
    //             applies to a range that is larger than 4 KiB and the size of the translation range is encoded in the PPN field.
    //         ''',
    //         resval: "0"
    //     }
    //     {
    //         bits: "53:10",
    //         name: "PPN",
    //         desc: '''
    //             If the fault bit is 0, then this field provides the PPN determined as a result of translating the iova_vpn in tr_req_iova.
    //             If the S bit is 0, then the size of the translation is 4 KiB - a page. 
    //             If the S bit is 1, then the translation resulted in a super-page, and the size of the super-page is encoded in the PPN itself.
    //         ''',
    //         resval: "0"
    //     }
    //     // skip reserved and custom bits
    //     ]
    // },
    {reserved: "3"},    // skip debug translation registers (capabilities.DBG = 0)
    {reserved: "17"},   // skip reserved and custom registers
    {
        # Interrupt-cause-to-vector register
        name: "icvec",
        desc: '''
            Interrupt-cause-to-vector register maps a cause to a vector. 
            All causes can be mapped to same vector or a cause can be given a unique vector.

            The Vector is used:

            By an IOMMU that generates interrupts as MSI, to index into MSI configuration table (msi_cfg_tbl) to determine the MSI to generate.
            By an IOMMU that generates WSI, to determine the wire to signal the interrupt.
        ''',
        swaccess: "rw",
        hwaccess: "hrw",
        fields: [
        {
            bits: "3:0",
            name: "civ",
            desc: "The command-queue-interrupt-vector (civ) is the vector number assigned to the command-queue-interrupt.",
            resval: "0"
        }
        {
            bits: "7:4",
            name: "fiv",
            desc: "The fault-queue-interrupt-vector (fiv) is the vector number assigned to the fault-queue-interrupt.",
            resval: "0"
        }
        {
            bits: "11:8",
            name: "pmiv",
            desc: "The performance-monitoring-interrupt-vector (pmiv) is the vector number assigned to the performance-monitoring-interrupt.",
            resval: "0"
        }
        {
            bits: "15:12",  // may be unused
            name: "piv",
            desc: "The page-request-queue-interrupt-vector (piv) is the vector number assigned to the page-request-queue-interrupt.",
            resval: "0"
        }
        // skip reserved and custom bits
        ]
    },
    #### MSI Configuration Table
    {
        # MSI Address Register #0
        name: "msi_addr_0",
        desc: '''
            MSI Message address register fields.
        ''',
        fields: [
        {
            bits: "1:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "ro",
            hwaccess: "hro"
        }
        {
            bits: "55:2",
            name: "ADDR",
            desc: "Holds the 4-byte aligned MSI address.",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Data Register #0
        name: "msi_data_0",
        desc: '''
            MSI Message data register fields.
        ''',
        fields: [
        {
            bits: "31:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Vector Control Register #0
        name: "msi_vec_ctl_0",
        desc: '''
            MSI Vector control register fields.
        ''',
        fields: [
        {
            bits: "0",
            name: "M",
            desc: '''
                When the mask bit M is 1, the corresponding interrupt vector is masked and the IOMMU is prohibited 
                from sending the associated message. Pending message for that vector are later generated if 
                the corresponding mask bit is cleared to 0.
            ''',
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Address Register #1
        name: "msi_addr_1",
        desc: '''
            MSI Message address register fields.
        ''',
        fields: [
        {
            bits: "1:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "ro",
            hwaccess: "hro"
        }
        {
            bits: "55:2",
            name: "ADDR",
            desc: "Holds the 4-byte aligned MSI address.",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Data Register #1
        name: "msi_data_1",
        desc: '''
            MSI Message data register fields.
        ''',
        fields: [
        {
            bits: "31:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Vector Control Register #1
        name: "msi_vec_ctl_1",
        desc: '''
            MSI Vector control register fields.
        ''',
        fields: [
        {
            bits: "0",
            name: "M",
            desc: '''
                When the mask bit M is 1, the corresponding interrupt vector is masked and the IOMMU is prohibited 
                from sending the associated message. Pending message for that vector are later generated if 
                the corresponding mask bit is cleared to 0.
            ''',
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Address Register #2
        name: "msi_addr_2",
        desc: '''
            MSI Message address register fields.
        ''',
        fields: [
        {
            bits: "1:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "ro",
            hwaccess: "hro"
        }
        {
            bits: "55:2",
            name: "ADDR",
            desc: "Holds the 4-byte aligned MSI address.",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Data Register #2
        name: "msi_data_2",
        desc: '''
            MSI Message data register fields.
        ''',
        fields: [
        {
            bits: "31:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Vector Control Register #2
        name: "msi_vec_ctl_2",
        desc: '''
            MSI Vector control register fields.
        ''',
        fields: [
        {
            bits: "0",
            name: "M",
            desc: '''
                When the mask bit M is 1, the corresponding interrupt vector is masked and the IOMMU is prohibited 
                from sending the associated message. Pending message for that vector are later generated if 
                the corresponding mask bit is cleared to 0.
            ''',
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Address Register #3
        name: "msi_addr_3",
        desc: '''
            MSI Message address register fields.
        ''',
        fields: [
        {
            bits: "1:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "ro",
            hwaccess: "hro"
        }
        {
            bits: "55:2",
            name: "ADDR",
            desc: "Holds the 4-byte aligned MSI address.",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Data Register #3
        name: "msi_data_3",
        desc: '''
            MSI Message data register fields.
        ''',
        fields: [
        {
            bits: "31:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Vector Control Register #3
        name: "msi_vec_ctl_3",
        desc: '''
            MSI Vector control register fields.
        ''',
        fields: [
        {
            bits: "0",
            name: "M",
            desc: '''
                When the mask bit M is 1, the corresponding interrupt vector is masked and the IOMMU is prohibited 
                from sending the associated message. Pending message for that vector are later generated if 
                the corresponding mask bit is cleared to 0.
            ''',
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Address Register #4
        name: "msi_addr_4",
        desc: '''
            MSI Message address register fields.
        ''',
        fields: [
        {
            bits: "1:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "ro",
            hwaccess: "hro"
        }
        {
            bits: "55:2",
            name: "ADDR",
            desc: "Holds the 4-byte aligned MSI address.",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Data Register #4
        name: "msi_data_4",
        desc: '''
            MSI Message data register fields.
        ''',
        fields: [
        {
            bits: "31:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Vector Control Register #4
        name: "msi_vec_ctl_4",
        desc: '''
            MSI Vector control register fields.
        ''',
        fields: [
        {
            bits: "0",
            name: "M",
            desc: '''
                When the mask bit M is 1, the corresponding interrupt vector is masked and the IOMMU is prohibited 
                from sending the associated message. Pending message for that vector are later generated if 
                the corresponding mask bit is cleared to 0.
            ''',
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Address Register #5
        name: "msi_addr_5",
        desc: '''
            MSI Message address register fields.
        ''',
        fields: [
        {
            bits: "1:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "ro",
            hwaccess: "hro"
        }
        {
            bits: "55:2",
            name: "ADDR",
            desc: "Holds the 4-byte aligned MSI address.",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Data Register #5
        name: "msi_data_5",
        desc: '''
            MSI Message data register fields.
        ''',
        fields: [
        {
            bits: "31:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Vector Control Register #5
        name: "msi_vec_ctl_5",
        desc: '''
            MSI Vector control register fields.
        ''',
        fields: [
        {
            bits: "0",
            name: "M",
            desc: '''
                When the mask bit M is 1, the corresponding interrupt vector is masked and the IOMMU is prohibited 
                from sending the associated message. Pending message for that vector are later generated if 
                the corresponding mask bit is cleared to 0.
            ''',
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Address Register #6
        name: "msi_addr_6",
        desc: '''
            MSI Message address register fields.
        ''',
        fields: [
        {
            bits: "1:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "ro",
            hwaccess: "hro"
        }
        {
            bits: "55:2",
            name: "ADDR",
            desc: "Holds the 4-byte aligned MSI address.",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Data Register #6
        name: "msi_data_6",
        desc: '''
            MSI Message data register fields.
        ''',
        fields: [
        {
            bits: "31:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Vector Control Register #6
        name: "msi_vec_ctl_6",
        desc: '''
            MSI Vector control register fields.
        ''',
        fields: [
        {
            bits: "0",
            name: "M",
            desc: '''
                When the mask bit M is 1, the corresponding interrupt vector is masked and the IOMMU is prohibited 
                from sending the associated message. Pending message for that vector are later generated if 
                the corresponding mask bit is cleared to 0.
            ''',
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Address Register #7
        name: "msi_addr_7",
        desc: '''
            MSI Message address register fields.
        ''',
        fields: [
        {
            bits: "1:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "ro",
            hwaccess: "hro"
        }
        {
            bits: "55:2",
            name: "ADDR",
            desc: "Holds the 4-byte aligned MSI address.",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Data Register #7
        name: "msi_data_7",
        desc: '''
            MSI Message data register fields.
        ''',
        fields: [
        {
            bits: "31:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Vector Control Register #7
        name: "msi_vec_ctl_7",
        desc: '''
            MSI Vector control register fields.
        ''',
        fields: [
        {
            bits: "0",
            name: "M",
            desc: '''
                When the mask bit M is 1, the corresponding interrupt vector is masked and the IOMMU is prohibited 
                from sending the associated message. Pending message for that vector are later generated if 
                the corresponding mask bit is cleared to 0.
            ''',
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Address Register #8
        name: "msi_addr_8",
        desc: '''
            MSI Message address register fields.
        ''',
        fields: [
        {
            bits: "1:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "ro",
            hwaccess: "hro"
        }
        {
            bits: "55:2",
            name: "ADDR",
            desc: "Holds the 4-byte aligned MSI address.",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Data Register #8
        name: "msi_data_8",
        desc: '''
            MSI Message data register fields.
        ''',
        fields: [
        {
            bits: "31:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Vector Control Register #8
        name: "msi_vec_ctl_8",
        desc: '''
            MSI Vector control register fields.
        ''',
        fields: [
        {
            bits: "0",
            name: "M",
            desc: '''
                When the mask bit M is 1, the corresponding interrupt vector is masked and the IOMMU is prohibited 
                from sending the associated message. Pending message for that vector are later generated if 
                the corresponding mask bit is cleared to 0.
            ''',
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Address Register #9
        name: "msi_addr_9",
        desc: '''
            MSI Message address register fields.
        ''',
        fields: [
        {
            bits: "1:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "ro",
            hwaccess: "hro"
        }
        {
            bits: "55:2",
            name: "ADDR",
            desc: "Holds the 4-byte aligned MSI address.",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Data Register #9
        name: "msi_data_9",
        desc: '''
            MSI Message data register fields.
        ''',
        fields: [
        {
            bits: "31:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Vector Control Register #9
        name: "msi_vec_ctl_9",
        desc: '''
            MSI Vector control register fields.
        ''',
        fields: [
        {
            bits: "0",
            name: "M",
            desc: '''
                When the mask bit M is 1, the corresponding interrupt vector is masked and the IOMMU is prohibited 
                from sending the associated message. Pending message for that vector are later generated if 
                the corresponding mask bit is cleared to 0.
            ''',
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Address Register #10
        name: "msi_addr_10",
        desc: '''
            MSI Message address register fields.
        ''',
        fields: [
        {
            bits: "1:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "ro",
            hwaccess: "hro"
        }
        {
            bits: "55:2",
            name: "ADDR",
            desc: "Holds the 4-byte aligned MSI address.",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Data Register #10
        name: "msi_data_10",
        desc: '''
            MSI Message data register fields.
        ''',
        fields: [
        {
            bits: "31:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Vector Control Register #10
        name: "msi_vec_ctl_10",
        desc: '''
            MSI Vector control register fields.
        ''',
        fields: [
        {
            bits: "0",
            name: "M",
            desc: '''
                When the mask bit M is 1, the corresponding interrupt vector is masked and the IOMMU is prohibited 
                from sending the associated message. Pending message for that vector are later generated if 
                the corresponding mask bit is cleared to 0.
            ''',
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Address Register #11
        name: "msi_addr_11",
        desc: '''
            MSI Message address register fields.
        ''',
        fields: [
        {
            bits: "1:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "ro",
            hwaccess: "hro"
        }
        {
            bits: "55:2",
            name: "ADDR",
            desc: "Holds the 4-byte aligned MSI address.",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Data Register #11
        name: "msi_data_11",
        desc: '''
            MSI Message data register fields.
        ''',
        fields: [
        {
            bits: "31:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Vector Control Register #11
        name: "msi_vec_ctl_11",
        desc: '''
            MSI Vector control register fields.
        ''',
        fields: [
        {
            bits: "0",
            name: "M",
            desc: '''
                When the mask bit M is 1, the corresponding interrupt vector is masked and the IOMMU is prohibited 
                from sending the associated message. Pending message for that vector are later generated if 
                the corresponding mask bit is cleared to 0.
            ''',
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Address Register #12
        name: "msi_addr_12",
        desc: '''
            MSI Message address register fields.
        ''',
        fields: [
        {
            bits: "1:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "ro",
            hwaccess: "hro"
        }
        {
            bits: "55:2",
            name: "ADDR",
            desc: "Holds the 4-byte aligned MSI address.",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Data Register #12
        name: "msi_data_12",
        desc: '''
            MSI Message data register fields.
        ''',
        fields: [
        {
            bits: "31:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Vector Control Register #12
        name: "msi_vec_ctl_12",
        desc: '''
            MSI Vector control register fields.
        ''',
        fields: [
        {
            bits: "0",
            name: "M",
            desc: '''
                When the mask bit M is 1, the corresponding interrupt vector is masked and the IOMMU is prohibited 
                from sending the associated message. Pending message for that vector are later generated if 
                the corresponding mask bit is cleared to 0.
            ''',
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Address Register #13
        name: "msi_addr_13",
        desc: '''
            MSI Message address register fields.
        ''',
        fields: [
        {
            bits: "1:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "ro",
            hwaccess: "hro"
        }
        {
            bits: "55:2",
            name: "ADDR",
            desc: "Holds the 4-byte aligned MSI address.",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Data Register #13
        name: "msi_data_13",
        desc: '''
            MSI Message data register fields.
        ''',
        fields: [
        {
            bits: "31:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Vector Control Register #13
        name: "msi_vec_ctl_13",
        desc: '''
            MSI Vector control register fields.
        ''',
        fields: [
        {
            bits: "0",
            name: "M",
            desc: '''
                When the mask bit M is 1, the corresponding interrupt vector is masked and the IOMMU is prohibited 
                from sending the associated message. Pending message for that vector are later generated if 
                the corresponding mask bit is cleared to 0.
            ''',
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Address Register #14
        name: "msi_addr_14",
        desc: '''
            MSI Message address register fields.
        ''',
        fields: [
        {
            bits: "1:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "ro",
            hwaccess: "hro"
        }
        {
            bits: "55:2",
            name: "ADDR",
            desc: "Holds the 4-byte aligned MSI address.",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Data Register #14
        name: "msi_data_14",
        desc: '''
            MSI Message data register fields.
        ''',
        fields: [
        {
            bits: "31:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Vector Control Register #14
        name: "msi_vec_ctl_14",
        desc: '''
            MSI Vector control register fields.
        ''',
        fields: [
        {
            bits: "0",
            name: "M",
            desc: '''
                When the mask bit M is 1, the corresponding interrupt vector is masked and the IOMMU is prohibited 
                from sending the associated message. Pending message for that vector are later generated if 
                the corresponding mask bit is cleared to 0.
            ''',
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Address Register #15
        name: "msi_addr_15",
        desc: '''
            MSI Message address register fields.
        ''',
        fields: [
        {
            bits: "1:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "ro",
            hwaccess: "hro"
        }
        {
            bits: "55:2",
            name: "ADDR",
            desc: "Holds the 4-byte aligned MSI address.",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Data Register #15
        name: "msi_data_15",
        desc: '''
            MSI Message data register fields.
        ''',
        fields: [
        {
            bits: "31:0",
            name: "zero",
            desc: "Fixed to zero (0).",
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    {
        # MSI Vector Control Register #15
        name: "msi_vec_ctl_15",
        desc: '''
            MSI Vector control register fields.
        ''',
        fields: [
        {
            bits: "0",
            name: "M",
            desc: '''
                When the mask bit M is 1, the corresponding interrupt vector is masked and the IOMMU is prohibited 
                from sending the associated message. Pending message for that vector are later generated if 
                the corresponding mask bit is cleared to 0.
            ''',
            resval: "0",
            swaccess: "rw",
            hwaccess: "hrw"
        }
        // skip reserved and custom bits
        ]
    },
    // {reserved: "32"},
    {reserved: "384"} 
    ]
}
// offset should end in 4096 (4 KiB)